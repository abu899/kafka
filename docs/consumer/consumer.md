# Consumer

프로듀서에서 send 하게되면, 카프카 클러스터의 토픽에 데이터가 들어오고 이를 활용하는게 컨슈머라고 볼 수 있다.

## Internal

<p align="center"><img src="img/1.png" width="80%"></p>

- Fetcher
  - 리더 파티션으로부터 레코드들을 미리 가져와서 대기
  - poll 하기전에 데이터를 가져옴
- poll
  - Fetcher 에 있는 레코드들을 리턴하는 함수
- ConsumerRecords
  - 처리하고자 하는 레코드들의 모음
  - 리스트로 데이터를 데이터를 처리하거나 병렬로도 처리할 수 있다
  - `오프셋이 포함`되어 있음
  - 처리가 완료된 데이터에 대해 커밋을 실행해야한다

## 컨슈머 그룹

- 특정 토픽에 대해 어떤 목적에 따라 데이터를 처리하는 컨슈머들을 묶은 그룹
  - 컨슈머 그룹내 컨슈머는 동일한 로직을 가진다
- 각각의 컨슈머 그룹은 서로 격리된 환경에서 안전하게 운영할 수 있도록 도와준다
- 기본적으로 컨슈머그룹이 `subscribe`를 통해 토픽을 구독하게 되면, 전체 파티션에 대해 데이터를 가져가게 된다

### 컨슈머 그룹 내 컨슈머가 파티션 갯수보다 많은 경우

<p align="center"><img src="img/2.png" width="80%"></p>

- 파티션 갯수보다 컨슈머가 많은 경우 유휴상태(Idle)
- 파티션을 할당받지 못했기에 스레드만 차지하고 실제 데이터를 처리하지 못함
  - 즉, 불필요한 스레드
- 따라서, 파티션 갯수만큼만 컨슈머를 띄워주는게 좋음

### 컨슈머 그룹을 활용하는 이유

<p align="center"><img src="img/3.png" width="80%"></p>

운영 서버의 주요 리소스인 CPU, 메모리 정보를 수집하는 데이터 파이프라인을 구축한다고 가정

- 카프카를 활용한 파이프라인이 아닌 경우 리소스를 적재하기 위해 동기적으로 데이터를 요청한다
  - 이 경우 동기적인 에이전트들은 하나의 장애가 발생하면 더이상 적재가 불가능해진다
- 카프카를 활용한 경우, 각각의 용도에 따라 서로 다른 컨슈머 그룹으로 데이터를 처리할 수 있다
  - 장애가 발생하더라도 개별적으로 처리가 가능하며, 각 그룹의 오프셋부터 다시 데이터를 적재할 수 있다

### 리밸런싱

<p align="center"><img src="img/4.png" width="80%"></p>

리밸런싱이란 토픽에 있는 파티션과 컨슈머 그룹의 컨슈머의 할당이 변경되는 과정이라고 볼 수 있다.

- 일부 컨슈머에 장애가 발생한다면, 매칭된 파티션에 대한 소유권이 정상적인 컨슈머로 넘어간다
- 리밸런싱이 발생하는 상황
  1. 컨슈머가 추가되는 상황
  2. 컨슈머가 제외되는 상황
- 리밸런싱은 데이터 처리 도중 언제든지 발생 가능하기에, 리밸런싱에 대응하는 로직을 작성해야한다
  - RebalanceListener
- 리밸런싱 시간은 토픽 내 파티션 갯수에 의존한다
  - 갯수에 따라 몇 분까지도 리밸런싱이 진행되게, 가능한 리밸런싱이 생기지 않게 운영해야함.

### 커밋

<p align="center"><img src="img/5.png" width="80%"></p>

브로커로부터 데이터를 어디까지 가져갔는지 커밋을 통해 기록한다.

- 특정 토픽의 파티션을 어떤 컨슈머 그룹이 어디까지 가져갔는지 `내부 토픽`에 기록됨
  - `__consumer_offsets`
- 컨슈머가 이슈가 발생하고 다시 정상 동작시 데이터 처리의 중복이 발생하지 않도록 한다
- 컨슈머에서 내부 로직을 짤 때 레코드를 처리하고 나면 `반드시 커밋`을 해야한다!

### Assignor

컨슈머와 파티션의 할당 정책.

- RangeAssignor
  - Default
  - 각 토픽에서 파티션을 숫자로 정렬, 컨슈머를 사전 순서로 정렬하여 할당
- RoundRobinAssignor
  - 모든 파티션을 컨슈머에서 번갈아 할당
- StickyAssignor
  - 최대한 파티션을 균등하게 배분
- 사실상, 파티션과 컨슈머는 1:1 매핑해서 운영하기에 크게 상관이 없음.

## 컨슈머의 주요 옵션

### 필수 옵션

- bootstrap.servers
  - 컨슈머가 데이터를 처리할 브로커의 `Hostname:Port`를 1개 이상 작성
  - 2개 이상을 입력하여 일부 브로커에 문제가 생겨도 접속하는데 문제가 없도록 설정
- key.deserializer
  - 레코드의 `메시지 키를 역직렬화`하는 클래스를 지정
- value.deserializer
  - 레코드의 `메시지 값을 역직렬화`하는 클래스를 지정

### 선택 옵션

- group.id
  - 컨슈머 그룹 아이디를 지정
  - `subscribe()` 메서드로 토픽을 구독할 때는 필수 옵션
  - 기본값은 null
- auto.offset.reset
  - 컨슈머 그룹이 파티션을 읽을 때 컨슈머 오프셋이 없는 경우 어느 오프셋 부터 읽을지 선택
    - 컨슈머 오프셋이 없다는 건 한번도 커밋한적이 없는 경우
  - 새로운 컨슈머 그룹을 운용할 때만 활용
  - 기본값은 latest
    - latest
    - 가장 높은(가장 최근에 넣은) 오프셋 부터 읽기 시작
    - earliest
      - 가장 낮은(가장 오래전에 넣은) 오프셋 부터 읽기 시작
    - none
      - 컨슈머 그룹이 커밋한 기록이 있는지 찾아본다
      - 기록이 없다면 오류 반환, 기록이 존재한다면 커밋 기록 이후 부터 읽기 시작
- enable.auto.commit
  - 자동 or 수동 커밋
  - 기본값은 true
- auto.commit.interval.ms
  - 자동 커밋일 경우, 오프셋 커밋 간격
  - 기본값은 5000(5초)
- max.poll.records
  - poll 메서드를 통해 반환되는 최대 레코드 갯수
  - 기본 값은 500
- heartbeat.interval.ms
  - 하트비트를 전송하는 시간 간격
  - 기본값은 3000(3초)
  - `session.timeout.ms`와 함께 컨슈머가 정상적으로 처리되는지 확인할 때 필요
- session.timeout.ms
  - 컨슈머가 브로커와 연결이 끊기는 최대 시간
  - 기본값은 10000(10초)
  - 하트비트가 마지막으로 오고나서 10초가 지나면 문제가 있다고 판단
- max.poll.interval.ms
  - poll 메서드를 호출하는 간격의 최대 시간
  - 기본 값은 30000(5분)
  - poll 메서드가 호출되고 5분이 지나도 poll 이 호출되지 않으면 리밸런싱을 판단하게 됨
- isolation.level
  - 트랜잭션 프로듀서가 레코드를 트랜잭션 단위로 보낼 경우 사용

## auto.offset.rest

컨슈머 오프셋의 존재 여부에 따라 동작하는 방식을 선택하는 옵션이다.

